#cursor implementation is FINISHED

18:58   
resuming arrow movement implementation.

19:01   
never mind it's done i guess
gonna start work on character movement ->
should be pretty straightforward - just need to copy move_chars <-

21:47   
yeah i have no clue why it's not working

21:54    
ok i figured it out:
basically, when we move the byte down to the new line
```
if self.cursor_column >= BUFFER_WIDTH {
    self.new_line();
}
```

it calls this fn
```
fn new_line(&mut self)
```

which does this
```
self.cursor_column = 0;
self.write_column = 0;
```
this works fine when we're typing normally, but if there's a cursor offset, the cursor position will just write over this character (why?)

fix attempt 1:
```
if self.cursor_column != self.write_column {
} else {
    self.cursor_column = 0;
    self.write_column = 0;
}
```

doesn't work because we increase row height here
```
else {
    self.cursor_row += 1;
    self.write_row += 1;
}
```

without doing anything to the cursor column; therefore its value becomes 81 (uh oh)

22:25
scrapping this solution, should be handling line movement in the move_chars fn anyway

2023-11-07
18:39
starting out again

2023-11-09
19:30
starting out one more time!

